gateway发起调用治理是通过
GovernanceGatewayFilterFactory
        toRun = addRetry(exchange, governanceRequest, toRun);
        toRun = addCircuitBreaker(exchange, governanceRequest, toRun);
        toRun = addBulkhead(governanceRequest, toRun);
        toRun = addRateLimiter(governanceRequest, toRun);
        
consumer收到gateway请求，通过aop的方式拦截springmvc请求
GovernanceRequestMappingHandlerAdapter
    CheckedFunction0<Object> next = pjp::proceed;
    DecorateCheckedSupplier<Object> dcs = Decorators.ofCheckedSupplier(next);

    try {
      SpringCloudInvocationContext.setInvocationContext();

      addCircuitBreaker(dcs, governanceRequest);
      addBulkhead(dcs, governanceRequest);
      addRateLimiting(dcs, governanceRequest);

      return dcs.get();
      
发送请求给provider的时候，如果是通过RestTemplate的方式，则增加两个Interceptor，一个是重试一个是负载均衡
  @Bean
  @ConditionalOnMissingBean
  @ConditionalOnMissingClass("org.springframework.retry.support.RetryTemplate")
  public RestTemplateCustomizer governanceRestTemplateCustomizer(
      final GovernanceClientHttpRequestInterceptor governanceClientHttpRequestInterceptor,
      final LoadBalancerInterceptor loadBalancerInterceptor) {
    return restTemplate -> {
      List<ClientHttpRequestInterceptor> list = new ArrayList<>(
          restTemplate.getInterceptors());
      list.add(loadBalancerInterceptor);
      list.add(governanceClientHttpRequestInterceptor);
      restTemplate.setInterceptors(list);
    };
  }
  
如果是通过feign，增加重试功能，也是通过aop来实现的，中间还有Request转GovernanceRequest的处理
  @Bean
  @ConditionalOnClass(name = "org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient")
  public GovernanceFeignClient governanceFeignClient(RetryHandler retryHandler) {
    return new GovernanceFeignClient(retryHandler);
  }
